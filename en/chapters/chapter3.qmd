# Chapter 3: CSS Basics

The profile page we built in the last chapter works, but it looks like it's from the 90s (you're probably not even old enough to remember). The headings are black, the background is white, the links are blue and underlined, and everything is aligned and cramped to the left. HTML gives you structure, but it doesn't give you control over how things look. That's what CSS is for.

CSS stands for Cascading Style Sheets. It's the language that controls colors, fonts, spacing, and layout. When you visit a website that looks good (or bad), that's CSS at work. HTML says "this is a heading." CSS says "this heading should be dark blue, 32 pixels tall, and have some space below it."

Like HTML, CSS isn't a programming language. You write rules that describe how elements should look, and the browser applies them. There are a few ways to attach those rules to your HTML.

## How CSS Connects to HTML

There are three ways to add CSS to an HTML page.

**Inline styles** go directly on an element using the `style` attribute:

```html
<p style="color: red; font-size: 18px;">This paragraph is red and larger.</p>
```

This works, but it's messy. If you want all your paragraphs to look the same, you'd have to copy that style attribute everywhere. And if you want to change it later, you'd have to find every instance to change.

**Internal stylesheets** go in a `<style>` tag in the `<head>`:

```html
<!DOCTYPE html>
<html>
<head>
    <title>My Page</title>
    <style>
        p {
            color: red;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <p>This paragraph is red and larger.</p>
    <p>So is this one.</p>
</body>
</html>
```

Now every paragraph on the page gets the same style. Change it once, it changes everywhere. This is already better, but the CSS is still tied to this specific HTML file.

**External stylesheets** put the CSS in a separate file, so we'd have a `style.css` file with:

```css
/* styles.css */
p {
    color: red;
    font-size: 18px;
}
```

And a `index.html` file with:

```html
<!DOCTYPE html>
<html>
<head>
    <title>My Page</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <p>This paragraph is red and larger.</p>
</body>
</html>
```

The `<link>` tag tells the browser to load `styles.css` and apply it to this page. This is the approach we actually use for real projects. It keeps your HTML clean and lets multiple pages share the same styles.

For the rest of this chapter, I'll show CSS rules and not necessarily show the related HTML. Assume they're either in a `<style>` tag or an external file.

## Selectors and Properties

A CSS rule has two parts: a selector (what to style) and a declaration block (how to style it):

```css
h1 {
    color: navy;
    font-size: 32px;
}
```

`h1` is the selector. It matches all `<h1>` elements on the page.

Inside the curly braces are declarations. Each declaration has a property (`color`, `font-size`) and a value (`navy`, `32px`). Properties and values are separated by a colon (`:`). Declarations end with a semicolon (`;`).

**Element selectors** match HTML tags:

```css
p {
    color: #333;
}

a {
    color: blue;
}

h1, h2, h3 {
    font-family: Georgia, serif;
}
```

That last one is a group selector. It applies the same style to `h1`, `h2`, and `h3` elements.

**Class selectors** match elements with a specific class attribute. They start with a dot:

```html
<p class="intro">This is the introduction.</p>
<p>This is a regular paragraph.</p>
```

And creating the style:

```css
.intro {
    font-size: 20px;
    font-weight: bold;
}
```

Only the paragraph with `class="intro"` gets the larger, bold text. Classes are reusable. You can put the same class on as many elements as you want.

**ID selectors** match a single element with a specific id. They start with a hash (`#`):

```html
<header id="main-header">
    <h1>My Website</h1>
</header>
```

And creating the style that applies to the id:

```css
#main-header {
    background-color: #f5f5f5;
    padding: 20px;
}
```

IDs should be unique on a page. Don't overuse this pattern, classes are more flexible and usually preferred.

**Descendant selectors** match elements inside other elements:

```css
nav a {
    color: white;
    text-decoration: none;
}
```

This matches `<a>` elements that are inside a `<nav>`. Links elsewhere on the page aren't affected.

**Combining selectors**:

```css
header nav a {
    color: white;
}

p.intro {
    font-size: 20px;
}
```

The first matches links inside nav inside header. The second matches paragraphs with the class "intro" (not all elements with that class, just paragraphs).

There are more selectors (attribute selectors, pseudo-classes, pseudo-elements), but these cover most of what you'll need.

## Common Properties

CSS has hundreds of properties. You'll use maybe thirty regularly, and look up the rest when you need them. Rather than listing them all, let's style a real element and introduce properties as we go.

Start with a page that has some text and a card:

```html
<body>
    <h1>My Website</h1>
    <p>Welcome to the site.</p>

    <div class="card">
        <h2>Latest Post</h2>
        <p>This is a preview of the post content...</p>
        <a href="/post/1">Read more</a>
    </div>
</body>
```

Without any CSS, this is black text on a white background in the browser's default font (usually Times New Roman). Everything is cramped against the left edge. Let's fix it piece by piece.

First, the typography. Set a font on the `body` and everything inside inherits it:

```css
body {
    font-family: Arial, Helvetica, sans-serif;
    font-size: 16px;
    line-height: 1.5;
    color: #333;
}
```

`font-family` takes a list of fonts. The browser uses the first one it has, so you provide fallbacks. Always end with a generic family (`serif`, `sans-serif`, `monospace`) as the last resort. `line-height` controls spacing between lines. A unitless number like `1.5` means 1.5 times the font size. This makes text much easier to read than the default (which is too tight).

The `color` property sets text color. `#333` is a dark gray hex code, softer than pure black. You can also use named colors (`red`, `navy`) or RGB values (`rgb(255, 0, 0)`), but hex codes are what you'll see most in real projects.

Now let's make the heading stand out:

```css
h1 {
    font-size: 32px;
    color: navy;
}
```

And style the card so it looks like an actual card:

```css
.card {
    background-color: #f9f9f9;
    border: 1px solid #ddd;
    border-radius: 8px;
    padding: 20px;
    max-width: 400px;
}
```

`background-color` does what you'd expect. `border` is shorthand for width, style, and color in one line. `border-radius` rounds the corners (higher values mean rounder). `padding` adds space between the card's edge and its content. `max-width` prevents the card from stretching across the entire page.

The link inside the card is the default blue with an underline. Let's change that:

```css
.card a {
    color: #2c3e50;
    text-decoration: none;
}

.card a:hover {
    text-decoration: underline;
}
```

`text-decoration: none` removes the underline. The `:hover` pseudo-class applies styles only when the mouse is over the element, so the underline comes back as a visual hint that it's clickable.

One property that comes up constantly is `text-align`:

```css
h1 {
    text-align: center;
}
```

This centers the text within its container. It works on any block element. You'll use it for headings, hero sections, and footers.

Finally, spacing. You control the space between elements with `margin` (outside the element) and `padding` (inside). The difference matters once you understand the box model (next section), but the shorthand is worth knowing now:

```css
.card {
    margin: 20px 0;     /* 20px top and bottom, 0 left and right */
    padding: 20px;       /* 20px on all four sides */
}
```

You can set each side individually (`margin-top`, `padding-left`), but the shorthand covers most cases. Two values means "vertical horizontal." Four values means "top right bottom left" (clockwise from the top).

That's enough to style most of what you'll build in the next few chapters. When you need a property we haven't covered, look it up. The MDN Web Docs (developer.mozilla.org) are the best reference.

## The Box Model

Every HTML element is a box. Each box has four layers, from inside to outside:

1. **Content**: The actual text, image, or other content
2. **Padding**: Space between the content and the border
3. **Border**: A line around the padding
4. **Margin**: Space between this element and neighboring elements

![The CSS Box Model](../images/chapter3/figure-3-1-en.svg)

The first three (content, padding, border) make up the element itself: its visible size on screen. Margin is different. It's not part of the element; it's the gap between this element and whatever is next to it.

This distinction matters when you set a width:

```css
.card {
    width: 300px;
    padding: 20px;
    border: 2px solid black;
    margin: 10px;
}
```

By default, `width` sets only the content width. The padding and border get added on top of that. So the element's visible size on screen is:

- Content: 300px
- Padding: 20px left + 20px right = 40px
- Border: 2px left + 2px right = 4px
- Visible width: 344px

The margin adds another 10px on each side, so the element occupies 364px of horizontal space on the page. But the element itself (the box you see) is 344px wide.

This math is annoying. You set `width: 300px` and the thing ends up 344px wide. There's a fix:

```css
* {
    box-sizing: border-box;
}
```

With `box-sizing: border-box`, `width` includes padding and border. Set `width: 300px` and the element is 300px wide, period. The browser subtracts space for padding and border from the content area automatically.

Most developers add this rule to every project. Put it at the top of your CSS file.

One more thing about margin: **margins collapse**. If two elements are stacked vertically and one has `margin-bottom: 20px` and the next has `margin-top: 30px`, the space between them is 30px, not 50px. The larger margin wins. This is intentional behavior, not a bug, but it surprises people. Padding never collapses.

## Layout with Flexbox

By default, HTML elements stack vertically. Headings, paragraphs, divs: they all sit on top of each other, taking up the full width. That's fine for a document, but most websites need elements side by side: navigation links in a row, cards in a grid, a sidebar next to the main content.

CSS had `float` for this, which was designed for wrapping text around images and got hacked into a layout tool. It was confusing and fragile. Flexbox (Flexible Box Layout) was built specifically for the job.

To use flexbox, you set `display: flex` on a container. The container's children then become "flex items" that you can arrange:

```html
<nav class="main-nav">
    <a href="/">Home</a>
    <a href="/about">About</a>
    <a href="/contact">Contact</a>
</nav>
```

```css
.main-nav {
    display: flex;
}
```

That single line puts the links side by side instead of stacked. But they're crammed together with no space between them. Add `gap` to fix that:

```css
.main-nav {
    display: flex;
    gap: 20px;
}
```

Now there's 20 pixels between each link. `gap` is cleaner than adding margin to each item individually because you don't have to worry about extra space on the first or last item.

The links are bunched up on the left side of the page. What if you want them spread across the full width? That's what `justify-content` controls:

```css
.main-nav {
    display: flex;
    justify-content: space-between;
}
```

`space-between` pushes the first item to the left edge, the last item to the right edge, and distributes the rest evenly in between. This is the most common choice for navigation bars. If you want everything centered instead, use `justify-content: center`. If you want equal space around every item (including the edges), use `space-evenly`. You don't need to memorize all the options. `space-between` and `center` handle most cases.

Vertical alignment works similarly. If items in a row have different heights (say, an icon next to text), they might not line up the way you want. `align-items` fixes that:

```css
.main-nav {
    display: flex;
    align-items: center;
}
```

This vertically centers all items within the container. Without it, items stretch to fill the container's height (the default behavior), which is sometimes what you want and sometimes not.

Centering something both horizontally and vertically on a page used to be surprisingly hard. With flexbox it's three lines:

```css
.centered-container {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;          /* full viewport height */
}
```

`justify-content` handles the horizontal axis, `align-items` handles the vertical axis. Done.

By default, flex items flow left to right in a row. Sometimes you want a vertical layout (a sidebar with stacked links, for example). `flex-direction: column` switches the axis:

```css
.sidebar {
    display: flex;
    flex-direction: column;
    gap: 10px;
}
```

One thing to know: when you change direction to `column`, the roles of `justify-content` and `align-items` swap. `justify-content` now controls the vertical axis and `align-items` controls the horizontal one. This makes sense if you think of `justify-content` as "along the direction items flow" and `align-items` as "across it," but it trips people up at first.

Here's a common full-page layout that shows flexbox doing real work:

```css
.page {
    display: flex;
    flex-direction: column;
    min-height: 100vh;
}

.page header {
    padding: 20px;
    background: #333;
    color: white;
}

.page main {
    flex: 1;             /* grow to fill available space */
    padding: 20px;
}

.page footer {
    padding: 20px;
    background: #333;
    color: white;
}
```

The page is a vertical flex container. Header and footer take the space they need. The `flex: 1` on `main` tells it to grow and fill whatever space is left. This keeps the footer at the bottom of the viewport even when there's not much content (a classic problem that was annoying to solve before flexbox).

## Hands-On: Styling the Profile Page

Let's make the profile page from Chapter 2 look better. Create a file called `profile.css` in the same folder as your `profile.html`.

First, link the stylesheet by adding this to the `<head>` of your HTML:
```html
<link rel="stylesheet" href="profile.css">
```

Now let's build the CSS step by step. Start with the basics:
```css
* {
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    line-height: 1.6;
    color: #333;
    margin: 0;
    padding: 0;
}
```

The `font-family` line uses system fonts. The browser picks whichever one the user's operating system has. This looks native on every platform.

Style the header:
```css
header {
    background-color: #2c3e50;
    color: white;
    padding: 40px 20px;
    text-align: center;
}

header h1 {
    margin: 0 0 10px 0;
    font-size: 2.5em;
}

header nav {
    display: flex;
    justify-content: center;
    gap: 20px;
}

header nav a {
    color: white;
    text-decoration: none;
    padding: 5px 10px;
}

header nav a:hover {
    text-decoration: underline;
}
```

The `:hover` pseudo-class applies when the mouse is over the element.

Style the main content:
```css
main {
    max-width: 800px;
    margin: 0 auto;
    padding: 40px 20px;
}

section {
    margin-bottom: 40px;
}

h2 {
    color: #2c3e50;
    border-bottom: 2px solid #3498db;
    padding-bottom: 10px;
}
```

`margin: 0 auto` centers a block element horizontally (the `auto` margins on left and right split the remaining space equally).

Now it's your turn. Using what you've learned, style these remaining elements:

**The skills list** should display as horizontal tags instead of bullet points. Remove the default list styling, use flexbox to arrange the items in a row, and make each skill look like a pill (background color, padding, rounded corners). Allow items to wrap if they don't fit on one line.

**The contact form** should have its fields stacked vertically with some space between them. Style the inputs and textarea with padding, a border, and rounded corners. Make the submit button stand out with a background color, and add a hover effect so users know it's clickable.

**The footer** should match the header's style (same background color, white text, centered).

Experiment and check your results in the browser as you go. If you get stuck, the `:focus` pseudo-class is useful for styling form fields when they're selected, and `cursor: pointer` on buttons tells the browser to show the pointing hand cursor.

::: {.callout-tip collapse="true"}
## Stuck? Solution available

If you've given it an honest try and are truly stuck, a completed version of this project is available at [github.com/Applied-Computing-League/practical-web-development/en/code/chapter3](https://github.com/Applied-Computing-League/practical-web-development/tree/main/en/code/chapter3). Try to solve it yourself first. You learn more from the struggle than from reading the answer.
:::

When you're done, your page should look something like this:

![The styled profile page](../images/chapter3/figure-3-2-en.png)

Try resizing your browser window. The layout should adapt reasonably well. The header stays centered, the content has a maximum width, and the skills wrap to new lines.

## Chapter Summary

- CSS controls how HTML elements look: colors, fonts, spacing, layout
- Connect CSS to HTML with `<link rel="stylesheet" href="file.css">`
- Selectors target elements: `p` (element), `.class` (class), `#id` (ID)
- The box model: content + padding + border + margin
- Use `box-sizing: border-box` to make width calculations simpler
- Flexbox handles layout: `display: flex`, `justify-content`, `align-items`, `gap`

We now have a styled page, but it's still static. In the next chapter, we'll start building a server that can generate pages dynamically.

## Exercises

1. Your profile page uses the color #2c3e50 in multiple places (header, footer, headings). What happens if you want to change it? Count how many places you'd need to update. Then look up CSS custom properties (variables) and refactor your CSS so the color is defined once and referenced everywhere. Change it to a new color by editing a single line.

2. Add a hover effect to the skill tags. Maybe they change color, grow slightly, or get a shadow. Look up `transform: scale()` and `box-shadow`.

3. Make the navigation links look like buttons (background color, padding, rounded corners). Then add two states: a hover effect that changes the background, and a style that visually marks the "current" page. You'll need to add a class to one of the nav links in your HTML and write a CSS rule for it.

4. Add a profile image (real or placeholder) to the header. Center it above your name. Make it circular using `border-radius: 50%`.

5. Create a "projects" section with three project cards side by side using flexbox. Each card should have a title, description, and a "View Project" link. Make the cards equal width (look up flex: 1). Then resize your browser window â€” what happens when the cards get too narrow? Look up flex-wrap and set a min-width on each card so they wrap to a new row on smaller screens.

6. Using developer tools, inspect your styled page. Find an element and try changing its CSS values in the inspector. Watch how the page updates in real time. This is useful for experimenting before changing your actual CSS file.
